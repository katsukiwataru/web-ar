/* 0 */

/* 1 */

/* 10 */

/* 11 */

/* 12 */

/* 13 */

/* 14 */

/* 15 */

/* 16 */

/* 17 */

/* 18 */

/* 19 */

/* 2 */

/* 20 */

/* 21 */

/* 22 */

/* 23 */

/* 24 */

/* 25 */

/* 26 */

/* 27 */

/* 28 */

/* 29 */

/* 3 */

/* 30 */

/* 31 */

/* 32 */

/* 33 */

/* 34 */

/* 35 */

/* 4 */

/* 5 */

/* 6 */

/* 7 */

/* 8 */

/* 9 */

/* webpackChunkName: "top" */

/* webpackChunkName: "user" */

/************************************************************************/

/******/

/***/

//         const domElement = window.document.createElement('a');

//         document.body.appendChild(domElement);

//         document.body.removeChild(domElement);

//         domElement.click();

//         domElement.download = 'pattern-' + (screenName || 'marker') + '.png';

//         domElement.href = markerUrl;

//         resolve(markerUrl);

//       THREEx.ArPatternFile.buildFullMarker(imgLocalURL, 0.5, 512, 'black', (markerUrl) => {

//       const patternBlob = new Blob([pattern], { type: 'text/plain' });

//       setPatternUrl(URL.createObjectURL(patternBlob));

//       });

//     THREEx.ArPatternFile.encodeImageURL(imgLocalURL, (pattern) => {

//     await new Promise((resolve) => {

//     const data: Twitter = await getUser(screenName);

//     const imgData = await imgDataRes.blob();

//     const imgDataRes = await fetch(data.profile_image_url_https.replace('_normal', ''));

//     const imgLocalURL = URL.createObjectURL(imgData);

//     });

//   (async () => {

//   changeMatrixMode: 'modelViewMatrix',

//   patternUrl,

//   return;

//   type: 'pattern',

//   })();

// Check if module is in cache

// Create a new module (and put it into the cache)

// Execute the module function

// Flag the module as loaded

// Object.prototype.hasOwnProperty.call

// Promise = chunk loading, 0 = chunk loaded

// Return the exports of the module

// The module cache

// The require function

// __webpack_public_path__

// add entry module to deferred list

// add entry modules from loaded chunk to deferred list

// create a fake namespace object

// define __esModule on exports

// define getter function for harmony exports

// expose the module cache

// expose the modules object (__webpack_modules__)

// getDefaultExport function for compatibility with non-harmony modules

// if (!patternUrl) {

// install a JSONP callback for chunk loading

// mode & 1: value is a module id, require it

// mode & 2: merge all properties of value into the ns

// mode & 4: return value when already ns object

// mode & 8|1: behave like require

// new THREEx.ArMarkerControls(arToolkitContext, group, {

// object to store loaded and loading chunks

// run deferred modules when all chunks ready

// run deferred modules when ready

// undefined = chunk not loaded, null = chunk preloaded/prefetched

// webGLRenderer.setSize(640, 480);

// webpackBootstrap

// }

// });
